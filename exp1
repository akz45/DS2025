#include <cmath> 
#include <iostream>
#include <vector>
#include <algorithm>
#include <ctime>
#include <cstdlib>
#include <random>

class Complex {
private:
    double real;   
    double imag;  

public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}
    double getReal() const { return real; }
    double getImag() const { return imag; }
    void setReal(double r) { real = r; }
    void setImag(double i) { imag = i; }
    double getModulus() const {
        return sqrt(real * real + imag * imag);
    }
    bool operator==(const Complex& other) const {
        return real == other.real && imag == other.imag;
    }

    friend std::ostream& operator<<(std::ostream& os, const Complex& c) {
        os << c.real << " + " << c.imag << "i";
        return os;
    }
};
void shuffleVector(std::vector<Complex>& vec) {
    std::srand(static_cast<unsigned>(std::time(nullptr)));
    std::random_shuffle(vec.begin(), vec.end());
}
int findComplex(const std::vector<Complex>& vec, const Complex& target) {
    for (int i = 0; i < vec.size(); ++i) {
        if (vec[i] == target) {
            return i;
        }
    }
    return -1;
}
void insertComplex(std::vector<Complex>& vec, int pos, const Complex& c) {
    if (pos < 0 || pos > vec.size()) {
        std::cout << "插入位置无效！" << std::endl;
        return;
    }
    vec.insert(vec.begin() + pos, c);
}
void deleteComplex(std::vector<Complex>& vec, int pos) {
    if (pos < 0 || pos >= vec.size()) {
        std::cout << "删除位置无效！" << std::endl;
        return;
    }
    vec.erase(vec.begin() + pos);
}
void uniqueVector(std::vector<Complex>& vec) {
    std::sort(vec.begin(), vec.end(), [](const Complex& a, const Complex& b) {
        if (a.getReal() != b.getReal()) {
            return a.getReal() < b.getReal();
        }
        return a.getImag() < b.getImag();
    });
    vec.erase(std::unique(vec.begin(), vec.end()), vec.end());
}
void bubbleSort(std::vector<Complex>& vec) {
    int n = vec.size();
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            double modJ = vec[j].getModulus();
            double modJ1 = vec[j + 1].getModulus();
            if (modJ > modJ1 || (modJ == modJ1 && vec[j].getReal() > vec[j + 1].getReal())) {
                std::swap(vec[j], vec[j + 1]);
            }
        }
    }
}
void merge(std::vector<Complex>& vec, int left, int mid, int right) {
    std::vector<Complex> temp;
    int i = left, j = mid + 1;
    while (i <= mid && j <= right) {
        double modI = vec[i].getModulus();
        double modJ = vec[j].getModulus();
        if (modI < modJ || (modI == modJ && vec[i].getReal() < vec[j].getReal())) {
            temp.push_back(vec[i++]);
        } else {
            temp.push_back(vec[j++]);
        }
    }
    while (i <= mid) {
        temp.push_back(vec[i++]);
    }
    while (j <= right) {
        temp.push_back(vec[j++]);
    }
    for (int k = 0; k < temp.size(); ++k) {
        vec[left + k] = temp[k];
    }
}
void mergeSort(std::vector<Complex>& vec, int left, int right) {
    if (left >= right) {
        return;
    }
    int mid = left + (right - left) / 2;
    mergeSort(vec, left, mid);
    mergeSort(vec, mid + 1, right);
    merge(vec, left, mid, right);
}
void testSortEfficiency() {
	std::vector<Complex> vec1;
	std::vector<Complex> vec2,vec3;
    int n = 1000; 
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double>dis(0,100);
    for(int k=0;k<n;++k){
    	double r =dis(gen);
    	double i =dis(gen);
    	vec1.push_back(Complex(r,i));
	}
    vec2 = vec1;
    vec3 = vec1;
    mergeSort(vec1, 0, vec1.size() - 1);
    std::vector<Complex> sortedVec = vec1;
    std::cout << "=== 冒泡排序效率测试 ===" << std::endl;
    vec1 = sortedVec;
    clock_t start = clock();
    bubbleSort(vec1);
    clock_t end = clock();
    std::cout << "有序情况：" << (end - start) / (double)CLOCKS_PER_SEC << " 秒" << std::endl;
    vec1 = vec2;
    start = clock();
    bubbleSort(vec1);
    end = clock();
    std::cout << "乱序情况：" << (end - start) / (double)CLOCKS_PER_SEC << " 秒" << std::endl;
    std::reverse(vec1.begin(), vec1.end());
    start = clock();
    bubbleSort(vec1);
    end = clock();
    std::cout << "逆序情况：" << (end - start) / (double)CLOCKS_PER_SEC << " 秒" << std::endl;
    std::cout << "\n=== 归并排序效率测试 ===" << std::endl;
    vec1 = sortedVec;
    start = clock();
    mergeSort(vec1, 0, vec1.size() - 1);
    end = clock();
    std::cout << "有序情况：" << (end - start) / (double)CLOCKS_PER_SEC << " 秒" << std::endl;
    vec1 = vec2;
    start = clock();
    mergeSort(vec1, 0, vec1.size() - 1);
    end = clock();
    std::cout << "乱序情况：" << (end - start) / (double)CLOCKS_PER_SEC << " 秒" << std::endl;
    std::reverse(vec1.begin(), vec1.end());
    start = clock();
    mergeSort(vec1, 0, vec1.size() - 1);
    end = clock();
    std::cout << "逆序情况：" << (end - start) / (double)CLOCKS_PER_SEC << " 秒" << std::endl;
}
std::vector<Complex> rangeSearch(const std::vector<Complex>& vec, double m1, double m2) {
    std::vector<Complex> result;
    for (const auto& c : vec) {
        double mod = c.getModulus();
        if (mod >= m1 && mod <= m2) {
            result.push_back(c);
        }
    }
    return result;
}
int main() {
    std::vector<Complex> vec;
    std::srand(static_cast<unsigned>(std::time(nullptr)));
    for (int i = 0; i < 10; ++i) {
        double r = std::rand() % 10;
        double im = std::rand() % 10;
        vec.push_back(Complex(r, im));
        // 加入重复元素
        if (i % 3 == 0) {
            vec.push_back(Complex(r, im));
        }
    }

    std::cout << "初始向量：" << std::endl;
    for (const auto& c : vec) {
        std::cout << c << "（模：" << c.getModulus() << "）" << std::endl;
    }

    // 测试置乱
    shuffleVector(vec);
    std::cout << "\n置乱后向量：" << std::endl;
    for (const auto& c : vec) {
        std::cout << c << std::endl;
    }

    // 测试查找
    Complex target(5, 5);
    int pos = findComplex(vec, target);
    if (pos != -1) {
        std::cout << "\n找到目标 " << target << "，位置：" << pos << std::endl;
    } else {
        std::cout << "\n未找到目标 " << target << std::endl;
    }

    // 测试插入
    insertComplex(vec, 2, Complex(10, 10));
    std::cout << "\n插入后向量：" << std::endl;
    for (const auto& c : vec) {
        std::cout << c << std::endl;
    }

    // 测试删除
    deleteComplex(vec, 2);
    std::cout << "\n删除后向量：" << std::endl;
    for (const auto& c : vec) {
        std::cout << c << std::endl;
    }

    // 测试唯一化
    uniqueVector(vec);
    std::cout << "\n唯一化后向量：" << std::endl;
    for (const auto& c : vec) {
        std::cout << c << "（模：" << c.getModulus() << "）" << std::endl;
    }

    // 测试排序效率
    testSortEfficiency();

    // 测试区间查找
    std::vector<Complex> sortedVec = vec;
    mergeSort(sortedVec, 0, sortedVec.size() - 1);
    std::cout << "\n排序后向量（用于区间查找）：" << std::endl;
    for (const auto& c : sortedVec) {
        std::cout << c << "（模：" << c.getModulus() << "）" << std::endl;
    }

    double m1 = 5, m2 = 10;
    std::vector<Complex> rangeVec = rangeSearch(sortedVec, m1, m2);
    std::cout << "\n模在 [" << m1 << ", " << m2 << "] 之间的元素：" << std::endl;
    for (const auto& c : rangeVec) {
        std::cout << c << "（模：" << c.getModulus() << "）" << std::endl;
    }

    return 0;
}
#include <iostream>
#include <string>
#include <cctype>
using namespace std;
template <typename T>
class Stack {
private:
    struct Node {
        T data;
        Node* next;
        Node(T val) : data(val), next(nullptr) {}
    };
    Node* topNode;

public:
    Stack() : topNode(nullptr) {}
    ~Stack() {
        while (!isEmpty()) {
            pop();
        }
    }
    void push(T data) {
        Node* newNode = new Node(data);
        newNode->next = topNode;
        topNode = newNode;
    }
    T pop() {
        if (isEmpty()) {
            throw "Stack is empty!";
        }
        Node* temp = topNode;
        T data = temp->data;
        topNode = topNode->next;
        delete temp;
        return data;
    }
    T top() const {
        if (isEmpty()) {
            throw "Stack is empty!";
        }
        return topNode->data;
    }
    bool isEmpty() const {
        return topNode == nullptr;
    }
};
double calculate(double num1, double num2, char op) {
    switch (op) {
        case '+': return num1 + num2;
        case '-': return num1 - num2;
        case '*': return num1 * num2;
        case '/': 
            if (num2 == 0) {
                throw "Division by zero!";
            }
            return num1 / num2;
        default: throw "Invalid operator!";
    }
}
int getPriority(char op) {
    if (op == '+' || op == '-') {
        return 1;
    } else if (op == '*' || op == '/') {
        return 2;
    } else {
        return 0;
    }
}
double stringCalculator(const string& expr) {
    Stack<double> numStack;
    Stack<char> opStack; 

    for (int i = 0; i < expr.size(); ++i) {
        char c = expr[i];
        if (isspace(c)) {
            continue;
        }
        if (isdigit(c) || c == '.') {
            string numStr;
            while (i < expr.size() && (isdigit(expr[i]) || expr[i] == '.')) {
                numStr += expr[i++];
            }
            i--;
            numStack.push(stod(numStr));
        }
        else if (c == '(') {
            opStack.push(c);
        }
        else if (c == ')') {
            while (!opStack.isEmpty() && opStack.top() != '(') {
                char op = opStack.pop();
                double num2 = numStack.pop();
                double num1 = numStack.pop();
                numStack.push(calculate(num1, num2, op));
            }
            if (opStack.isEmpty() || opStack.top() != '(') {
                throw "Mismatched parentheses!";
            }
            opStack.pop();
        }

        else if (c == '+' || c == '-' || c == '*' || c == '/') {
            while (!opStack.isEmpty() && opStack.top() != '(' && 
                   getPriority(opStack.top()) >= getPriority(c)) {
                char op = opStack.pop();
                double num2 = numStack.pop();
                double num1 = numStack.pop();
                numStack.push(calculate(num1, num2, op));
            }
            opStack.push(c);
        }
        else {
            throw "Invalid character in expression!";
        }
    }
    while (!opStack.isEmpty()) {
        char op = opStack.pop();
        if (op == '(') {
            throw "Mismatched parentheses!";
        }
        double num2 = numStack.pop();
        double num1 = numStack.pop();
        numStack.push(calculate(num1, num2, op));
    }

    if (numStack.isEmpty() || !opStack.isEmpty()) {
        throw "Invalid expression!";
    }
    return numStack.pop();
}
int main() {
    try {
        string expr;
        cout << "请输入表达式：";
        getline(cin, expr);
        double result = stringCalculator(expr);
        cout << "计算结果：" << result << endl;
    } catch (const char* msg) {
        cout << "错误：" << msg << endl;
    }
    return 0;
}#include <iostream>
#include <vector>
#include <stack>
#include <ctime>
using namespace std;

// 计算柱状图中最大矩形面积
int largestRectangleArea(vector<int>& heights) {
    int n = heights.size();
    if (n == 0) return 0;
    
    vector<int> left(n, -1);  // 记录每个柱子左边第一个更矮的柱子的索引
    vector<int> right(n, n); // 记录每个柱子右边第一个更矮的柱子的索引
    stack<int> stk;          // 单调栈，存储柱子索引，保持高度递增
    
    // 计算left数组
    for (int i = 0; i < n; ++i) {
        while (!stk.empty() && heights[stk.top()] >= heights[i]) {
            stk.pop();
        }
        if (!stk.empty()) {
            left[i] = stk.top();
        }
        stk.push(i);
    }
    
    // 清空栈，计算right数组
    while (!stk.empty()) stk.pop();
    for (int i = n - 1; i >= 0; --i) {
        while (!stk.empty() && heights[stk.top()] >= heights[i]) {
            stk.pop();
        }
        if (!stk.empty()) {
            right[i] = stk.top();
        }
        stk.push(i);
    }
    
    // 计算最大面积
    int maxArea = 0;
    for (int i = 0; i < n; ++i) {
        int width = right[i] - left[i] - 1;
        maxArea = max(maxArea, heights[i] * width);
    }
    return maxArea;
}

// 随机生成测试数据并测试
void test() {
    srand(time(0));
    for (int t = 0; t < 10; ++t) {
        int len = rand() % 105 + 1; // 长度1~105
        vector<int> heights(len);
        for (int i = 0; i < len; ++i) {
            heights[i] = rand() % 105; // 高度0~104
        }
        int area = largestRectangleArea(heights);
        cout << "测试用例 " << t + 1 << "：长度=" << len << "，最大面积=" << area << endl;
    }
}

int main() {
    test();
    return 0;
}
